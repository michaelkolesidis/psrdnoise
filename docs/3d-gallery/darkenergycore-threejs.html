<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>

<title>Dark energy catalyst core</title>
<meta charset="utf-8">
<link type="text/css" rel="stylesheet" href="psrdnoise.css">

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>

<script type="text/javascript" id="mainCode">
var
    container,
    renderer,
    scene,
    camera,
    mesh,
	material,
    start = Date.now(),
    fov = 45;

window.addEventListener( 'load', function() {
    container = document.getElementById( "three-container" );
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(
        fov,
        1.0,
        0.1,
        100 );
    camera.position.z = 3.0;
    material = new THREE.ShaderMaterial( {
		uniforms: {
			time: {
				type: "f",
				value: 0.0
			},
		},
    vertexShader: document.getElementById('vs-main').textContent,
    fragmentShader: document.getElementById('fs-includes').textContent
	  + "\r\n" + document.getElementById( 'fs-main' ).textContent
	} );

	mesh = new THREE.Mesh(new THREE.SphereGeometry( 1.0, 20, 20 ), material);
	scene.add( mesh );

	renderer = new THREE.WebGLRenderer();
	renderer.setSize( 600, 600 );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.getContext().getExtension("OES_standard_derivatives");

	const orbit = new THREE.OrbitControls( camera, renderer.domElement );
	container.appendChild( renderer.domElement );

	onWindowResize();
	window.addEventListener( 'resize', onWindowResize );

	render();
} );

function onWindowResize () {
	renderer.setSize( 600, 600 );
	camera.aspect = 1.0;
	camera.updateProjectionMatrix();
}

function render() {
    material.uniforms[ 'time' ].value = .001 * ( Date.now() - start );
    renderer.render( scene, camera );
    requestAnimationFrame( render );
}

</script>

</head>

<body style="max-width: 600px;">
  <h1>3-D psrdnoise: Dark energy catalyst core</h1>
  <p>This uses static psrdnoise for the burly orange pattern on the "shell",
  and animated psrdnoise for the "inside poking through the holes".
  Both patterns use two components of noise for some pattern variety.
  </p>
	<div class="canvas" id="three-container">
	</div>
  <p>As a side note, the object is a Voronoi tessellated Fibonacci sphere, a nudge to our normal selection algorithm for "psrdnoise". The "sphere" is a very plain low resolution mesh, and the facets and chamfers are an illusion generated by the fragment shader, totally unrelated to the polygons of the mesh. We use the inverse mapping algorithm published by Keinert et al in "Spherical Fibonacci Mapping", ACM Transactions on Graphics vol. 34(2015)6:193, but ported to GLSL and extended to return the four closest neighbors of the grid rather than just the closest one. This enabled us to use barycentric interpolation to compute normals along the chamfered edges.</p>
</body>

<script type="x-shader/x-vertex" id="vs-main">

uniform float time;

varying vec3 uvw;
varying vec2 st;
varying vec3 newnormal;

void main()
{
	uvw = position;
	st = uv;
	newnormal = (modelViewMatrix * vec4(normal,0.0)).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}

</script>

<script type="x-shader/x-fragment" id="fs-main">

uniform float time;
uniform mat4 modelViewMatrix;

varying vec2 st;
varying vec3 uvw;

void main()
{
	const float FibonacciN = 80.0;

	// These feature sizes scale with N
	float edgewidth = 0.4/sqrt(FibonacciN);
	float spotsize = 0.6/sqrt(FibonacciN);

	vec3 p0, p1, p2, p3;
	float k0, k1, k2, k3;
	vec3 p = vec3(0.0); // Don't use periodicity of psrdnoise
	vec3 g;  // But do use its gradient (it's very useful)

    vec3 v = normalize(uvw); // Renormalize after interpolation
	// Find the four closest N-fib-sphere points to v
	inverseSF(v, FibonacciN, k0, p0, k1, p1, k2, p2, k3, p3);
	float d0 = length(v-p0); // Worley would call this "F1"
	float d1 = length(v-p1); // "F2"
	float d2 = length(v-p2); // "F3"
	float d3 = length(v-p3); // "F4"
	float dots = 1.0-aastep(spotsize, d0); // Proper AA

	// Barycentric coordinates for chamfered normals
	float b0 = smoothstep(-edgewidth, edgewidth, (d1-d0));
	float b1 = smoothstep(-edgewidth, edgewidth, (d0-d1));
	float b2 = smoothstep(-edgewidth, edgewidth, (d0-d2));
	float b3 = smoothstep(-edgewidth, edgewidth, (d0-d3));
	// float bn = b0 + b1 + b2 + b3;
	vec3 facetN = normalize(p0*b0 + p1*b1 + p2*b2 + p3*b3);

	// This noise is unpublished work, to appear in JCGT
	float n = psrdnoise(10.0*v+time, p, 8.0*time, g);
	vec3 corecolor = (0.5+2.0*n)*vec3(0.0,0.5,1.0);
	float detail = psrdnoise(50.0*v, p, 0.0, g);
	detail += psrdnoise(50.0*v+0.15*g, p, 0.0, g);
	vec3 spherecolor = vec3(1.0,0.5,0.0)*(0.9+0.1*detail);

	// "Fake" lighting (don't bother with Three.js lights)
	mat3 MV3 = mat3(modelViewMatrix);
	facetN = MV3*facetN;
	vec3 Lpos = vec3(2.0); // Local light for nice highlight
	vec3 L = normalize(Lpos-MV3*uvw);
	float d = 0.2 + 0.5*max(dot(L, facetN), 0.0);
	float s = pow(max(reflect(-L, facetN).z, 0.0),15.0);
	vec3 white = vec3(1.0);
	vec3 mixcolor = d*spherecolor + s*white;
	mixcolor = mix(mixcolor, corecolor, dots);

	gl_FragColor = vec4(mixcolor, 1.0);
}

</script>

<script type="x-shader" id="vs-includes">
</script>

<script type="x-shader" id="fs-includes">

#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif

#ifdef GL_ES
precision highp float;
#endif

// Find point closest to p on an n-point Fibonacci sphere.
// Taken from the article "Spherical Fibonacci Mapping" by
// Keinert et al, ACM Trans. on Graphics 34 (2015), 6, 193.
// Ported from HLSL to GLSL by Stefan Gustavson 2021, with
// lots of fixes to get all four distances to neighbors
// correct for all points at or near Voronoi edges.

// Values for pi and the golden ratio (sqrt(5)+1)/2
#define PI 3.14159265359
#define PHI 1.61803398875

float madfrac(float a, float b) {
  return a*b - floor(a*b);
}

mat2 inv2x2(mat2 m) { // WebGL 1.0 doesn't have this built-in
	float a,b,c,d;
	a = m[0][0]; b = m[1][0]; c = m[0][1]; d = m[1][1];
	return mat2(d, -b, -c, a) / (a*d - b*c);
}

// Compute point k on N-point fibsphere (for patching below)
vec3 evalSFpoint(float k, float N) {
	float phi = 2.0*PI*madfrac(k, PHI-1.0);
	float cosTheta = 1.0 - (2.0*k + 1.0)*(1.0/N);
	float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
	return vec3(cos(phi)*sinTheta, sin(phi)*sinTheta,cosTheta);
}

// Add a specific point to the search (for patching below)
float fillinSF(float k, float knew, vec3 p, float N, float k0,
	inout float k1, inout float d1, inout vec3 p1,
	inout float k2, inout float d2, inout vec3 p2,
	inout float k3, inout float d3, inout vec3 p3)
{
	if((k0 == k) && (k1 != knew) && (k2 != knew) && (k3 != knew)) {
		vec3 q = evalSFpoint(knew, N);
		float d = dot(p-q, p-q);
		if((k1 == k0) || (d < d1)) {
			p3 = p2; p2 = p1; p1 = q;
			d3 = d2; d2 = d1; d1 = d;
			k3 = k2; k2 = k1; k1 = knew;
			return 1.0; // Changed a neighbor
		}
		if((k2 == k0) || (k2 == k1) || (d < d2)) {
			p3 = p2; p2 = q;
			d3 = d2; d2 = d;
			k3 = k2; k2 = knew;
			return 1.0; // Changed a neighbor
		}
		if((k3 == k0) || (k3 == k1) || (k3 == k2) || (d < d3)) {
			p3 = q;
			d3 = d;
			k3 = knew;
			return 1.0; // Changed a neighbor
		}
	}
	return 0.0; // No change
}

// Return all four neighbors. k3 is often very wrong near the poles,
// most notably for our usual culprits: cells 0, 1, 2 and 6 and their
// -z pole counterparts N-1, N2-, N-3 and N-7, so there are optional
// patch statements after the main algorithm. They make the shader
// code considerably longer, but they don't add much to the run time
// in the typical use cases. Most statements are skipped for most
// fragments, and GPU hardware has a shortcut for "dead branches".
//
float inverseSF(vec3 p, float N,
		out float k0, out vec3 p0, out float k1, out vec3 p1,
		out float k2, out vec3 p2, out float k3, out vec3 p3) {
	float phi = min(atan(p.y, p.x), PI); // min() to dodge NaN
	float cosTheta = p.z;
	float k = max(2.0, floor(
		log(N * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))
		/ log(PHI*PHI)));
	float Fk = pow(PHI, k)/sqrt(5.0);
	float F0 = floor(Fk + 0.5);
	float F1 = floor(Fk * PHI + 0.5);
	mat2 B = mat2(2.0*PI*madfrac(F0+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0),
		2.0*PI*madfrac(F1+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0),
		-2.0*F0/N, -2.0*F1/N);
	mat2 invB = inv2x2(B);
	vec2 c = floor(invB * vec2(phi, cosTheta - (1.0-1.0/N)));
	float dsqmin = 10.0;

	// Compute all four neighbors first, *then* find closest points
	// (Complete sorting is more efficient with all values available)
	cosTheta = dot(B[1], vec2(0.0, 0.0) + c) + (1.0-1.0/N);
	cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;
	k0 = floor(N*0.5 - cosTheta*N*0.5);
	p0 = evalSFpoint(k0, N);
	float d0 = dot(p-p0, p-p0);

	cosTheta = dot(B[1], vec2(1.0, 0.0) + c) + (1.0-1.0/N);
	cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;
	k1 = floor(N*0.5 - cosTheta*N*0.5);
	p1 = evalSFpoint(k1, N);
	float d1 = dot(p-p1, p-p1);

	cosTheta = dot(B[1], vec2(0.0, 1.0) + c) + (1.0-1.0/N);
	cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;
	k2 = floor(N*0.5 - cosTheta*N*0.5);
	p2 = evalSFpoint(k2, N);
	float d2 = dot(p-p2, p-p2);

	cosTheta = dot(B[1], vec2(1.0, 1.0) + c) + (1.0-1.0/N);
	cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;
	k3 = floor(N*0.5 - cosTheta*N*0.5);
	p3 = evalSFpoint(k3, N);
	float d3 = dot(p-p3, p-p3);

	// Sorting: make p0, p1, p2 the three closest points
	// (and hence p3 the fourth closest, if it's valid)
	// and don't accept a duplicate of p0 for p1, nor
	// for p2 unless no other options are available.
	// This makes p1 correct near Voronoi cell edges, which
	// is what we care most about. There are still some errors
	// for p1 in the interior of cells, most notably around
	// the very problematic poles, but that's a minor flaw.
	// Grave errors remain in p2 and p3 around poles, due to
	// duplicates or wrong candidates for the closest points.
	// Optional patches to fix that are available at the end.
	vec3 pswap;
	float dswap, kswap;
	if(d1 < d0) {
		// swap p0,p1
		pswap = p1; p1 = p0; p0 = pswap;
		dswap = d1; d1 = d0; d0 = dswap;
		kswap = k1; k1 = k0; k0 = kswap;
	}
	if(d2 < d0) {
		// swap p0,p2
		pswap = p2; p2 = p0; p0 = pswap;
		dswap = d2; d2 = d0; d0 = dswap;
		kswap = k2; k2 = k0; k0 = kswap;
	}
	if(d3 < d0) {
		// swap p0,p3
		pswap = p3; p3 = p0; p0 = pswap;
		dswap = d3; d3 = d0; d0 = dswap;
		kswap = k3; k3 = k0; k0 = kswap;
	}
	if((k1 == k0) // If k1 is a duplicate of k0, always swap
		|| ((d2 < d1) && (k2 != k0))) { // if closer and not a dup
		// swap p1,p2
		pswap = p2; p2 = p1; p1 = pswap;
		dswap = d2; d2 = d1; d1 = dswap;
		kswap = k2; k2 = k1; k1 = kswap;
	}
	if((k1 == k0) // If k1 is a duplicate of k0, always swap
		|| ((d3 < d1) && (k3 != k0))) { // if closer and not a dup
		// swap p1,p3
		pswap = p3; p3 = p1; p1 = pswap;
		dswap = d3; d3 = d1; d1 = dswap;
		kswap = k3; k3 = k1; k1 = kswap;
	}
	// p3 is particularly bad near poles
	if((k2 == k0) || (k2 == k1) // If k2 dup of k0 or k1, swap
		|| ((d3 < d2) && (k3 != k0) && (k3 != k1))) {
		// swap p2,p3
		pswap = p3; p3 = p2; p2 = pswap;
		dswap = d3; d3 = d2; d2 = dswap;
		kswap = k3; k3 = k2; k2 = kswap;
	}

	// Patch run: add the most important missing candidates
	// near poles, to fix errors in p2 and p3 that affect
	// regions near zeroes of d2-d0 and d3-d0. This makes
	// reasonably narrow Voronoi edges and junctions
	// (3-junctions as well as "near-4-junctions") appear
	// correct in barycentric interpolations using all four
	// distances to neighbors in the mix.

	vec3 q;
	float d;
	float npatches;

#define PATCH
#ifdef PATCH
	// High priority fixes (affect edges and junctions)
	// North pole
	npatches += fillinSF(0.0, 5.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(0.0, 8.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(1.0, 4.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(1.0, 6.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(1.0, 9.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(2.0, 4.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(2.0, 10.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(2.0, 15.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(3.0, 16.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(5.0, 18.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(6.0, 14.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(6.0, 19.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(10.0, 15.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	// South pole
	npatches += fillinSF(N-1.0, N-6.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-1.0, N-9.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-2.0, N-5.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-2.0, N-7.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-2.0, N-10.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-3.0, N-5.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-3.0, N-11.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-3.0, N-16.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-4.0, N-17.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-6.0, N-19.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-7.0, N-15.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-7.0, N-20.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
	npatches += fillinSF(N-11.0, N-16.0, p,N,k0,k1,d1,p1,k2,d2,p2,k3,d3,p3);
#endif

	return npatches;
}
		
float aastep(float threshold, float value) {
	float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));
	return smoothstep(threshold-afwidth, threshold+afwidth, value);
}

vec3 hashcolor(float i){
	float r = mod(i, 289.0);
	r = mod((r*34.0+10.0)*r, 289.0);
	float g = mod(i+r, 361.0);
	g = mod((g*38.0+8.0)*g, 361.0);
	float b = mod(i+g, 529.0);
	b = mod((b*46.0+18.0)*b, 529.0);
	return vec3(r,g,b)/vec3(289.0, 361.0, 529.0);
}


// psrdnoise (c) Stefan Gustavson and Ian McEwan,
// ver. 2021-12-02, published under the MIT license:
// https://github.com/stegu/psrdnoise/

vec4 permute(vec4 i) {
	vec4 im = mod(i, 289.0);
	return mod(((im*34.0)+10.0)*im, 289.0);
}

float psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)
{
	const mat3 M = mat3(0.0, 1.0, 1.0, 1.0, 0.0, 1.0,  1.0, 1.0, 0.0);
	const mat3 Mi = mat3(-0.5, 0.5, 0.5, 0.5,-0.5, 0.5, 0.5, 0.5,-0.5);
	vec3 uvw = M * x;
	vec3 i0 = floor(uvw), f0 = fract(uvw);
	vec3 g_ = step(f0.xyx, f0.yzz), l_ = 1.0 - g_;
	vec3 g = vec3(l_.z, g_.xy), l = vec3(l_.xy, g_.z);
	vec3 o1 = min( g, l ), o2 = max( g, l );
	vec3 i1 = i0 + o1, i2 = i0 + o2, i3 = i0 + vec3(1.0);
	vec3 v0 = Mi * i0, v1 = Mi * i1, v2 = Mi * i2, v3 = Mi * i3;
	vec3 x0 = x - v0, x1 = x - v1, x2 = x - v2, x3 = x - v3;
	if(any(greaterThan(period, vec3(0.0)))) {
		vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);
		vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);
		vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);
		if(period.x > 0.0) vx = mod(vx, period.x);
		if(period.y > 0.0) vy = mod(vy, period.y);
		if(period.z > 0.0) vz = mod(vz, period.z);
		i0 = floor(M * vec3(vx.x, vy.x, vz.x) + 0.5);
		i1 = floor(M * vec3(vx.y, vy.y, vz.y) + 0.5);
		i2 = floor(M * vec3(vx.z, vy.z, vz.z) + 0.5);
		i3 = floor(M * vec3(vx.w, vy.w, vz.w) + 0.5);
	}
	vec4 hash = permute( permute( permute( 
			vec4(i0.z, i1.z, i2.z, i3.z ))
			+ vec4(i0.y, i1.y, i2.y, i3.y ))
			+ vec4(i0.x, i1.x, i2.x, i3.x ));
	vec4 theta = hash * 3.883222077;
	vec4 sz = hash * -0.006920415 + 0.996539792;
	vec4 psi = hash * 0.108705628;
	vec4 Ct = cos(theta), St = sin(theta);
	vec4 sz_prime = sqrt( 1.0 - sz*sz );
	vec4 gx, gy, gz;
	if(alpha != 0.0) {
		vec4 px = Ct * sz_prime, py = St * sz_prime, pz = sz;
		vec4 Sp = sin(psi), Cp = cos(psi), Ctp = St*Sp - Ct*Cp;
		vec4 qx = mix( Ctp*St, Sp, sz), qy = mix(-Ctp*Ct, Cp, sz);
		vec4 qz = -(py*Cp + px*Sp);
		vec4 Sa = vec4(sin(alpha)), Ca = vec4(cos(alpha));
		gx = Ca*px + Sa*qx; gy = Ca*py + Sa*qy; gz = Ca*pz + Sa*qz;
	}
	else {
		gx = Ct * sz_prime; gy = St * sz_prime; gz = sz;  
	}
	vec3 g0 = vec3(gx.x, gy.x, gz.x), g1 = vec3(gx.y, gy.y, gz.y);
	vec3 g2 = vec3(gx.z, gy.z, gz.z), g3 = vec3(gx.w, gy.w, gz.w);
	vec4 w = 0.5-vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));
	w = max(w, 0.0); vec4 w2 = w * w, w3 = w2 * w;
	vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));
	float n = dot(w3, gdotx);
	vec4 dw = -6.0 * w2 * gdotx;
	vec3 dn0 = w3.x * g0 + dw.x * x0;
	vec3 dn1 = w3.y * g1 + dw.y * x1;
	vec3 dn2 = w3.z * g2 + dw.z * x2;
	vec3 dn3 = w3.w * g3 + dw.w * x3;
	gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);
	return 39.5 * n;
}

</script>

</html>
