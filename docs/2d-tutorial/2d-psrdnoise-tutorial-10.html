<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<title>2-D PSRDnoise tutorial 10</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">

<link type="text/css" rel="stylesheet" href="2d-psrdnoise-tutorial.css">

<script type="text/javascript" src="2d-drawquad.js"></script>

<script type="text/javascript" src="syntaxhighlighter_3.0.83/scripts/shCore.js"></script>
<script type="text/javascript" src="syntaxhighlighter_3.0.83/scripts/shBrushGLSL.js"></script>
<link type="text/css" rel="stylesheet" href="syntaxhighlighter_3.0.83/styles/shCoreEclipse.css"/>

<script type="text/javascript">
function showshader() {
	codepane = document.getElementById("fragmentcode");
	codepane.innerHTML = document.getElementById("shader-fs-visible").textContent;
	SyntaxHighlighter.highlight(codepane);
}
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec2 texcoord;

    varying vec2 st;

    void main(void) {
        gl_Position = vec4(position, 1.0);
        st = texcoord;
    }
</script>

<script id="shader-fs-hidden" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif


// psrdnoise (c) Stefan Gustavson and Ian McEwan,
// ver. 2021-12-02, published under the MIT license:
// https://github.com/stegu/psrdnoise/

float psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)
{
	vec2 uv = vec2(x.x+x.y*0.5, x.y);
	vec2 i0 = floor(uv), f0 = fract(uv);
	float cmp = step(f0.y, f0.x);
	vec2 o1 = vec2(cmp, 1.0-cmp);
	vec2 i1 = i0 + o1, i2 = i0 + 1.0;
	vec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);
	vec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);
	vec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);
	vec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;
	vec3 iu, iv, xw, yw;
	if(any(greaterThan(period, vec2(0.0)))) {
		xw = vec3(v0.x, v1.x, v2.x);
		yw = vec3(v0.y, v1.y, v2.y);
		if(period.x > 0.0)
			xw = mod(vec3(v0.x, v1.x, v2.x), period.x);
		if(period.y > 0.0)
			yw = mod(vec3(v0.y, v1.y, v2.y), period.y);
		iu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);
	} else {
		iu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);
	}
	vec3 hash = mod(iu, 289.0);
	hash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);
	hash = mod((hash*34.0 + 10.0)*hash, 289.0);
	vec3 psi = hash*0.07482 + alpha;
	vec3 gx = cos(psi); vec3 gy = sin(psi);
	vec2 g0 = vec2(gx.x, gy.x);
	vec2 g1 = vec2(gx.y, gy.y);
	vec2 g2 = vec2(gx.z, gy.z);
	vec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));
	w = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;
	vec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));
	float n = dot(w4, gdotx);
	vec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;
	vec2 dn0 = w4.x*g0 + dw.x*x0;
	vec2 dn1 = w4.y*g1 + dw.y*x1;
	vec2 dn2 = w4.z*g2 + dw.z*x2;
	gradient = 10.9*(dn0 + dn1 + dn2);
	return 10.9*n;
}

</script>

<script id="shader-fs-visible" type="x-shader/x-fragment">
varying vec2 st;
uniform float time;

void main(void) {

	const float scale = 6.0;
	vec2 v = scale * (st-0.5);
	const vec2 p = vec2(8.0, 8.0);
	float alpha = 0.5*time;
	vec2 g;

	float n = 0.5;
	n += 0.4*psrdnoise(v, p, alpha, g);
	n += 0.2*psrdnoise(2.0*v+0.1, p*2.0, 2.0*alpha, g);
	n += 0.1*psrdnoise(3.0*v+0.2, p*4.0, 4.0*alpha, g);
	n += 0.05*psrdnoise(8.0*v+0.3, p*8.0, 8.0*alpha, g);
	n += 0.025*psrdnoise(16.0*v, p*16.0, 16.0*alpha, g);

	vec3 noisecolor = vec3(n);
	gl_FragColor = vec4(noisecolor, 1.0);
}

</script>

</head>

<body onload="webGLStart(); showshader();">
<h2>2-D PSRDnoise tutorial</h2>
<h3>
	<a class="navigation" href="2d-psrdnoise-tutorial-01.html">Page 1</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-02.html">2</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-03.html">3</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-04.html">4</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-05.html">5</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-06.html">6</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-07.html">7</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-08.html">8</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-09.html">9</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-10.html">10</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-11.html">11</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-12.html">12</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-13.html">13</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-14.html">14</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-15.html">15</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-16.html">16</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-17.html">17</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-18.html">18</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-19.html">19</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-20.html">20</a>&nbsp;
	<a class="navigation" href="2d-psrdnoise-tutorial-21.html">21</a>
</h3>
 <div class="grid-container">
  <div class="canvas">
    <canvas id="psrdnoise-canvas" style="border: none;" width="500" height="500"></canvas>
	<p>
	<form onsubmit="return false;">Frame rate:
	<input type="text" disabled id="fpscounter" size="4"/> FPS
	</form>
	</p>
  </div>
  <div class="code">
    <h1>10: Animated fractal sum</h1>
	<p>This pattern is a "fractal sum" of several alpha-animated noise components with different feature sizes. This is one of the most common uses of noise, and now the slightly regular structure of the grid and the cyclic animation with "alpha" are completely masked by the emergent complexity of the "fractal cloud" pattern.</p>
	<p>Note that we add different small offsets to the scaled texture coordinates for each of the noise components, the "octaves". This is because we don't want the grid points to coincide between components. In that case, some points would always have the value zero. This is mostly inconsequential to the general look of the fractal sum, but in some circumstances it creates a less random-looking pattern.</p>
	<p>Note also that the animation of "alpha" is slower for large features, and faster for small features. This mimics the behavior of turbulent flow, where small swirls spin faster than large swirls because of the physics involved, and it creates a "natural" (or, rather, "believable") look for the overall animation.</p>
	<p>The pattern is cyclic and repeats with every 4*pi seconds. If this is not what you want, you can change the rotation speeds for alpha to not be even multiples of each other. Put some irrational numbers in there, and the pattern will never repeat itself.</p>
	<p>And, just for fun, we made the pattern periodic again in (x,y). Every component repeats across the edges of this visible square, so their sum repeats as well.</p>
	<p>If you don't care for a repeating texture, set the components of "p" to 0.0 and let the noise roam free across the plane. Additionally, consider using scale factors between "octaves" that are not exactly powers of two. Non-integer scale factors are less prone to create accidental regularity in the final pattern.</p>
	<pre class="brush: GLSL;" id="fragmentcode">
	// Text in this pane will be dynamically replaced.
	</pre>
  </div>
</div>
</body>

</html>
